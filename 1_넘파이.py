# -*- coding: utf-8 -*-
"""1. 넘파이.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TR_906_v8OfJq9iRcTswLtjhXHP5hr_S

#**1. 넘파이(Numpy)**
넘파이(Numpy)는 파이썬에서 사용되는 과학 및 수학 연산을 위한 강력한 <mark>라이브러리</mark>입니다. 주로 다차원 배열을 다루는 데에 특화되어 있어, 데이터 분석, 머신러닝, 과학 계산 등 다양한 분야에서 널리 사용됩니다. 넘파이 배열은 C언어로 구현되어 있어 연산이 빠르고 효율적입니다. 특히 큰 데이터셋에서 수치 연산을 수행할 때 뛰어난 성능을 보입니다. 또한 메모리 사용을 최적화하고 효율적으로 관리합니다.

※ 다차원 배열(multidimensional array) : 배열 안에 또 배열이 있는 구조를 말합니다.
"""

# pip install numpy 설치

import numpy as np

"""#**2. 넘파이의 주요 특징과 기능**
### 1. 다차원 배열(N-dimensional array)
넘파이의 핵심은 다차원 배열인 ndarray(엔.디.어레이)입니다. ndarray는 동일한 자료형을 가지는 원소들로 이루어져 있습니다. 다차원 배열은 1차원, 2차원, 3차원 등 차원을 가질 수 있습니다.

※ ndarray는 "다차원 배열"의 한 구현체(객체) 이름입니다.
뜻은 거의 같지만 "어디에 쓰느냐"가 다릅니다.
- 다차원 배열은 개념적인 말입니다.
- ndarray는 그 개념을 NumPy 라는 라이브러리에서 실제로 구현한 클래스 이름입니다.
<mark>nd</mark>는 n-dimensional의 줄임말입니다.
즉 **numpy.ndarray -> n차원 배열 클래스
"""

list1 = [1, 2, 3, 4]
print(list1)
print(type(list1))
print(type(list1[0]))

list2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
print(list2)
print(type(list2))
print(type(list2[0]))

ndarr1 = np.array([1, 2, 3, 4])
print(ndarr1)
print(type(ndarr1))
print(type(ndarr1[0]))

ndarr2 = np.array([[1, 2, 3], [4, 5, 6]])
print(ndarr2)
print(type(ndarr2))
print(type(ndarr2[0]))

"""### 2. 리스트와 ndarray 변환
데이터 타입을 다른 데이터 타입으로 변환할 수 있습니다. 리스트에서 배열로 변환은 np.array() 함수를 사용하고, 배열에서 리스트로 변환은 tolist() 메서드를 사용합니다.
"""

# 리스트를 ndarray로 변환
list1 = [1, 2, 3, 4]
ndarr1 = np.array(list1)
print(ndarr1)
print(type(ndarr1))

# ndarray를 리스트로 변환
list2 = ndarr1.tolist()
print(list2)
print(type(list2))

"""### 3. ndarray의 데이터 타입
넘파이의 ndarray는 동일한 자료형을 가지는 원소들로 이루어져 있으며, 다양한 데이터 타입을 지원합니다.

※ 원소(element) : 배열 안에 들어 있는 <mark>하나 하나의 데이터 값</mark>을 말합니다.
즉, ndarray는 **여러 개의 원소(element)로 이루어진 다차원 배열**입니다.
"""

list1 = [1, 3.14, 'python', '😊', True]
print(list1)
print(type(list1))
print(type(list1[0]))
print(type(list1[1]))
print(type(list1[2]))
print(type(list1[3]))
print(type(list1[4]))

ndarr1 = np.array([1, 2, 3, 4])
print(ndarr1)
print(type(ndarr1))
print(type(ndarr1[0]))
print(type(ndarr1[1]))
print(type(ndarr1[2]))
print(type(ndarr1[3]))

"""##**※ 알고 가세요**

모든 원소(element)는 같은 자료형(dtype) 을 가져야 합니다.

**💡 모든 원소가 같은 자료형이어야 하는 이유**
NumPy의 <code>ndarray</code>는 **빠른 계산**을 위해 만들어진 구조입니다.
이걸 가능하게 하는 핵심이 바로 **모든 원소의 자료형이 동일하다**는 점입니다.

1. 메모리에 연속적으로 저장하기 위해서.<br>
덕분에 CPU가 빠르게 읽고 계산할 수 있어요.
2. 벡터화 연산이 가능해집니다.<br>
모든 원소가 통일되어 있기 때문에 C언어 기반의 벡터화 연산으로 한 번에 계산할 수 있기 때문입니다.
3. 다양한 데이터 타입 지원은 하나만 통일해서.<br>
NumPy는 다양한 타입을 지원하지만 하나의 배열 안에서는 반드시 동일해야 해요.

### 🧠 한 줄 요약
<code>ndarray의 원소들이 모두 같은 자료형을 가져야 하는 이유는 **메모리 효율성 + 빠른 수학 연산(벡터화) 때문입니다.</code>

>Q. "만약 같은 원소타입을 넣지 않고 ndarray 에 다른 타입의 원소를 넣으면 어떻게 되나요?"<br>
A. **NumPy가 자동으로 하나의 공통 자료형으로 변환(cast) 합니다.

예를들면 다음과 같습니다.
- **int + float**은<br>
[1, 2.5, 3] -> [1. 2.5 3.] 으로 type은 "float64"
- **int + String**은<br>
[1, "hello", 3] -> ['1', 'hello', '3'] 으로 문자열로 변환
- **bool + int**은
[True, 2, 3] -> [1 2 3] 으로 type은 "int64"

### **정리**
ndarray는 같은 자료형을 가져야 하지만,
만약 다른 타입이 들어오면 NumPy가 자동으로 하나의 통일된 타입으로 변환한다.
이걸 타입 승격(type promotion) 또는 자동 형 변환(casting) 이라고 부른다.
### 타입 승격 규칙
*bool → int → float → complex → str*
"""

arr = np.array([1, "hello", 3])
print(arr)
print(type(arr))

ndarr2 = np.array([1, 2, 3.14, 4])
print(ndarr2 , 'ndarray 값 : [1, 2, 3.14, 4]')
print(type(ndarr2))
print(type(ndarr2[0]))
print(type(ndarr2[1]))
print(type(ndarr2[2]))
print(type(ndarr2[3]))

print('-' * 30)

ndarr3 = np.array([1, 2, 3.14, True])
print(ndarr3 , 'ndarray 값 : [1, 2, 3.14, True]')
print(type(ndarr3))
print(type(ndarr3[0]))
print(type(ndarr3[1]))
print(type(ndarr3[2]))
print(type(ndarr3[3]))

print('-' * 30)

ndarr4 = np.array(['1', 2, 3.14, True])
print(ndarr4 , 'ndarray 값 : ["1", 2, 3.14, True]') # Corrected syntax here
print(type(ndarr4))
print(type(ndarr4[0]))
print(type(ndarr4[1]))
print(type(ndarr4[2]))
print(type(ndarr4[3]))

print('-' * 30)

ndarr3 = np.array([1, 2, 3.14, True], dtype=int)
print(ndarr3 , 'ndarray 값 : [1, 2, 3.14, True], dtype=int')
print(type(ndarr3))
print(type(ndarr3[0]))
print(type(ndarr3[1]))
print(type(ndarr3[2]))
print(type(ndarr3[3]))

print('-' * 30)

ndarr4 = np.array(['1', 2, 3.14, True], dtype=int)
print(ndarr4 , 'ndarray 값 : ["1", 2, 3.14, True], dtype=int') # Corrected syntax here
print(type(ndarr4))
print(type(ndarr4[0]))
print(type(ndarr4[1]))
print(type(ndarr4[2]))
print(type(ndarr4[3]))

"""### 4. ndarray의 인덱싱과 슬라이싱
넘파이의 ndarray는 리스트와 유사하게 인덱싱과 슬라이싱을 지원합니다.
"""

ndarr1 = np.array(['🍓', '🍉', '🍌', '🍒', '🍑'])
print(ndarr1)
print(ndarr1.shape)

# 인덱싱
print(ndarr1[0])
print(ndarr1[4])
print(ndarr1[-1])
print(ndarr1[-2])

# 슬라이싱
print(ndarr1[0:3])
print(ndarr1[2:])
print(ndarr1[:3])

# 2차원 배열
ndarr2d = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12]])
print(ndarr2d)
print(ndarr2d.shape , '행 : 3, 열 : 4')

# 0행 가져오기
print(ndarr2d[0, :])
print(ndarr2d[0,])
print(ndarr2d[0])

# 각 행에 0열 가져오기
print(ndarr2d[:, 0])

ndarr1 = np.array([10, 15, 2, 8, 20, 90, 85, 44, 23, 32])
idx = [2, 5, 9]
print(ndarr1[idx])

print('-' * 30)

ndarr2d = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12]])
print(ndarr2d[[0, 1], :])

ndarr1 = np.array(['🍓', '🍉', '🍌', '🍒', '🍑'])
sel = [True, False, True, True, False]
print(ndarr1[sel])

print('-' * 30)

ndarr2d = np.array([[1, 2, 3, 4],
                    [5, 6, 7, 8],
                    [9, 10, 11, 12]])

print(ndarr2d > 7)
print(ndarr2d[ndarr2d > 7])

"""#**3. 행렬 연산**
넘파이에서는 다차원 배열인 ndarray를 사용하여 행렬 연산을 수행할 수 있습니다. 행렬 연산은 선형 대수와 관련이 싶기 때문에 데이터 과학, 머신러닝, 통계 등 다양한 분야에서 사용됩니다.

**※ 선형 대수**
선형 대수는 벡터와 행렬을 사용해 공간과 변환을 다루는 수학의 한 분야입니다. 쉽게 말해, 여러 숫자를 체계적으로 배열한 벡터(리스트 같은 것)와 행렬(숫자가 격자로 배열된 표)을 이용해 데이터를 표현하고 조작하는 방법입니다. 선형 대수는 컴퓨터 그래픽스, 머신러닝, 물리학, 공학 등 다양한 분야에서 사용됩니다. 예를 들어, 사진에서 색상을 조정하거나, 로봇이 움직일 경로를 계산하거나, AI가 데이터를 분석하는데 선형 대수가 필요합니다.
"""

# 짝이 맞는 행, 열 끼리 연산합니다
a = np.array([[1, 2, 3],
              [2, 3, 4]])
b = np.array([[3, 4, 5],
              [1, 2, 3]])
print(a.shape, b.shape)
print('-' * 30)

# 행렬 원소별 덧셈
print(a + b)
print('-' * 30)

# 행렬 원소별 뺄셈
print(a - b)
print('-' * 30)

# 행렬 원소별 곱셈
print(a * b)
print('-' * 30)

# 행렬 원소별 곱셈
print(a / b)

"""### ※ 행렬곱
행렬곱은 두 행렬을 곱해서 새로운 행렬을 만드는 연산으로, 데이터의 변환이나 계산에서 많이 사용됩니다. 행렬은 숫자를 격자로 배열한 것으로, 벡터나 데이터를 다루는 데 유용합니다.
연산 기호는 <code>@</code>를 사용하며, np.dot() 과 같은 역할입니다.

※  행렬곱의 규칙
1. 첫 번째 행렬의 열(가로 숫자 개수)과 두 번째 행렬의 행(세로 숫자 개수)이 같아야 합니다.
예: A가 2×3 행렬이고 B가 3×2 행렬이라면, A와 B를 곱할 수 있습니다.
2. 결과 행렬은 첫 번째 행렬의 행 개수 × 두 번째 행렬의 열 개수입니다.
예: A(2×3) × B(3×2) → 결과는 2×2 행렬.
3. 행렬곱은 첫 번째 행렬의 한 행과 두 번째 행렬의 한 열을 각각 곱한 뒤 더해서 계산합니다.
"""

ndarr3 = np.array([[1, 2, 3],
                   [1, 2, 3],
                   [2, 3, 4]])
ndarr4 = np.array([[1, 2],
                   [3, 4],
                   [5, 6]])
print(ndarr3.shape)
print(ndarr4.shape)

print('-' * 30)

print((1*1 + 2*3 + 3*5), (1*2 + 2*4 + 3*6))
print((1*1 + 2*3 + 3*5), (1*2 + 2*4 + 3*6))
print((2*1 + 3*3 + 4*5), (2*2 + 3*4 + 4*6))

print('-' * 30)

print(ndarr3 @ ndarr4)
# 행렬 곱셈 또는 벡터 내적을 수행
np.dot(ndarr3, ndarr4)

"""#**4. 순차적인 값 생성**
NumPy에서 np.arange() 함수는 일정한 간격으로 숫자들을 생성하는 데 사용됩니다. 이 함수는 Python의 기본 range() 함수와 유사하지만, NumPy 배열을 반환하므로 수학적인 연산이 가능합니다.
"""

arr1 = range(1, 11)
print(arr1)
print(type(arr1))

for i in arr1:
    print(i, end=' ')

print('\n', '-' * 30)

arr2 = np.arange(1, 11)
print(arr2)
print(type(arr2))

for i in arr2:
    print(i, end=' ')

"""#**5. 정렬**
NumPy의 np.sort() 함수는 배열을 정렬하는 데 사용됩니다. 이 함수는 기본적으로 원래 배열을 변경하지 않고 정렬된 배열의 복사본을 반환합니다.
"""

ndarr1 = np.array([1, 10, 5, 7, 2, 4, 3, 6, 8, 9])
print(ndarr1)

print(np.sort(ndarr1)) # 오름차순 정렬

print(np.sort(ndarr1)[::-1]) # 내림차순 정렬

print('\n', '-' * 30, '\n')

ndarr2d = np.array([[11, 10, 12, 9],
                    [3, 1, 4, 2],
                    [5, 6, 7, 8]])
print(ndarr2d.shape)

print('-' * 30)

print('열 단위로 정렬. 각 열의 값들을 개별적으로 오름차순으로 정렬하며, 행(row)의 순서는 재배열')
print( np.sort(ndarr2d, axis=0) )

print('행(row) 단위로 정렬. 각 행의 원소들이 개별적으로 오름차순으로 정렬')
print( np.sort(ndarr2d, axis=1) )

print('행 단위로 정렬한 후, 각 행의 값을 역순으로 정렬하는 동작을 수행')
print( np.sort(ndarr2d, axis=1)[:, ::-1] )

print('axis=1과 동일하게 동작.')
print('-1은 배열의 마지막 축을 기준으로 동작하라는 의미. 2차원 배열에서 마지막 축은 axis=1을 나타냄')
print( np.sort(ndarr2d, axis=-1) )

"""#**AI 개인공부**
NumPy를 이용하여 성적 분석하기를 한번 해볼까 합니다. 응용력에 큰 도움이 될것이라 생각합니다.

[NumPy를 이용하여 성적 분석하기](https://www.notion.so/NumPy-29944640f85b80859a50eccfe34cb996)

### Step 1 — 점수표 만들기
"""

score = np.random.randint(60, 100, size = (5, 3))
student = ('김사과', '반하나', '오랜지', '채애리', '오지환')

for scores in zip(student, score):
    print(scores)

"""### Step 2 — 평균 계산"""

avg = np.mean(score, axis=1)
avg = np.round(avg, 1)

for avg in zip(student, avg):
    print(avg)

avg = np.mean(score, axis=1)
avgRound = np.round(avg, 1)

for avgRound in zip(student, avgRound):
    print(avgRound)

"""### Step 3 — 평균을 기준으로 순위 매기기"""

order = np.argsort(-avg)

for rank, (name, mean) in enumerate(
        zip(np.array(student)[order], np.round(avg[order], 1)),
        start=1
    ):
    print(f"{rank}등 | {name} | {mean}")

"""### Step 4 — 결과 정리해서 보기 좋게 출력"""

for rank, (name, scores, mean) in enumerate(
        zip(np.array(student)[order], score[order], np.round(avg[order], 1)),
        start=1
    ):
    print(f"{rank}등 | {name} | 점수 {scores} | {mean}")

"""### Step 5 — 과목별 최고 점수"""

subjects = np.array(['국어', '수학', '영어'])
bestSubjects = subjects[np.argmax(score, axis=1)]
bestScores = np.max(score, axis=1)

print(np.argmax(score, axis=1))
print(np.max(score, axis=1))

for name, scores, val in zip(student, bestScores, bestSubjects):
    print(f"{name} | 최고점: {scores} ({val})")